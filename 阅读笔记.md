---
                       阅读笔记   
                                      --刘鸿志
---
[TOC]
### Java程序运行机制

&emsp;&emsp;先对Java程序的运行机制做一个概述.Java程序是运行在Java虚拟机(JVM),上而不是直接运行在设备上的.JVM大致的模型如下:  

&emsp;&emsp;首先程序编译生成的.class文件经过Class Loader加载（负责对数据进行校验和初始化），然后再在Runtime Data Area开辟程序运行时所需要的内存区域（包括堆栈内存、函数区内存、常量区、程序固定内存等等，部分为线程共享），对数据管理。分配完内存后就是通过java虚拟机进行解释执行，并通过native library与其他编程语言交互。  

---

### 程序的并发机制

&emsp;&emsp;所谓并发，一般都是与并行相对来讲的，通俗来说。并发是指多任务以时间片轮转的形式有序执行等，从而导致宏观上像是多任务同时进行（并行）。并发机制一般表现为**多线程**或**多进程**的形式。而对于这种多任务并发的形式，首先要分析多任务之间如何交流。  

#### 多线程及其之间通信  
&emsp;&emsp;对于多进程而言,得提到上面讲过的JVM中的内存区的管理，Java虚拟机内存模型（JMM）如下图：  

&emsp;&emsp;其中主存区中的堆内存和函数区的内存都是线程共享的，而每个线程也单独拥有自己的堆栈内存。  

&emsp;&emsp;所谓线程共享，即每个线程都会在自身的堆栈内存中为共享区域的内存保留一份copy，然后单独操作自己的copy。若要实现对共享内存区的共同维护，则需要通过Synchronized同步锁或者Lock锁对象**(安全)**或者对共享变量添加volatile关键字**（不安全）**的方式实现。  

&emsp;&emsp;举个例子，代码如下，当线程A执行`Market m = new Market();	m.buy();`后，线程B读取goods值为4，原因是二者维护的是同一块内存区域（位于主存的变量goods）。如果按注释那样去掉volatile关键字，A线程再进行同样的操作，B线程获取到的goods值却为5，原因正是AB两个线程这个时候维护的是各自对主存这块区域的copy，所以互不影响。  

```java
public class Market{
    // public int goods = 5;
    public volatile int goods = 5;
    public void buy(){
        this.goods--;
    }
}
```

&emsp;&emsp;但是这里常常有一个误区，那就是关于volatile关键字与Synchronized同步锁机制的区别。volatile修饰的变量是**不具有原子性**的，只能保证对内存区域的修改对于其他线程可见。也就是当多个线程同时对volatile进行修改操作后，所得的值会与预计中的有差异。但Synchronized同步锁会使多线程对同一内存区域的读取具有同步性，从而实现原子性的操作。就好比很多人都有钥匙，但只能一个一个地开锁进去。使用Synchronized同步锁的实例如下（生产者消费者的例子）：  

&emsp;&emsp;关于线程间具体的通信，还需要用到`wait()`跟`notify()`配合的线程等待和唤醒机制，但这种方式下notify不能唤醒指定的线程，所以一般都使用Lock绑定多个condition监视，然后通过condition对象来使指定的线程等待或唤醒。  

&emsp;&emsp;Lock锁的使用实例如下，  

#### 线程池的原理和搭建

&emsp;&emsp;所谓线程池，通俗来说就是容放多个线程的空间，线程池内的线程并发执行多个任务。当有任务需要执行时，线程池会派出一个线程去执行。当线程执行完任务后就会回到线程池等待分配新的任务而不是立刻销毁。直到线程池所有线程都被使用，多余的任务就会进入等待队列等待，直到线程池出现新的闲置的线程。

##### 源码分析

&emsp;&emsp;有关线程池的类与接口的关系可参考下图：
	
//executor\executorservice等等关系图
	
&emsp;&emsp;Java中通过`Executors`提供4种线程池的创建，分别如下：

- `Executors.newCachedThreadPool()`提供一个线程数量不固定的线程池（最多2147483647个线程，Integer的最大值,可视为无限数量），线程池内的线程回收后的60s内可执行其它任务，若闲置时间超过60s就会自动销毁。返回类型为`ExecutorService`（实际为`ThreadPoolExecutor`对象的向上转型）。  

- `Executors.newFixedThreadPool()` 提供一个线程数量固定的线程池，执行完任务的线程不会销毁，在线程池中等待。线程数量通过参数指定，返回对象类型为`ExecutorService`（也为`ThreadPoolExecutor`对象的向上转型）。


- `Executors.newScheduledThreadPool()`提供一个线程数量固定的线程池，与上一个类型的线程池相比，这个线程池能够定时地启动			返回对象类型为`ScheduledExecutorService`（实际为`ScheduledThreadPoolExecutor`）。   

- `Executors.newSingleThreadExecutor()`提供一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行 。返回对象类型为`ExecutorService`（ 实际为`ThreadPoolExecutor`）。   



&emsp;&emsp;Java中线程池的搭建离不开`ThreadPoolExecutor`类，`ThreadPoolExecutor`类是继承自`AbstractExecutorService`抽象类,该类实现了`Executor`、`ExecutorService`接口,`Executor`接口内只有`void execute(Runnable command)`接口函数，抽象了具体的任务执行过程。

&emsp;&emsp;由于`ExcutorService()`内部抽象函数比较多，挑几个主要的讲。`submit()`接口抽象了任务的执行提交过程，与`execute()`方法相似而又不同的是，该方法返回了一个`Future`对象来表示任务执行的结果，`Future`类提供有`cancel()`函数能够取消掉执行中的任务（前提是任务还未执行完毕）。
	
//线程池的搭建


### Android 分析  

#### Android系统架构分析  

&emsp;&emsp;Android架构主要分为四部分，从底层到顶层依次为**Linux Kernel**(内核层)，**Libraries**(共享库，以及android运行时库，**Android Runtime**)，**Application Framework**(应用框架层)，**Application**(应用程序),重点研究的源码也集中于Framework层。  

&emsp;&emsp;首先对这4个部分作个简单的介绍：

- 其中Application主要指的是系统应用，如桌面、闹钟、文件管理、设置、日历、电话、短信等。

- Application Framework,为App程序提供各种API，是应用程序的框架，为应用程序提供各种组建和服务，由于上层的应用程序是以JAVA构建的，因此本层次提供了以下服务：  

   //1. 丰富而又可扩展的视图(Views)，可以用来构建应用程序， 它包括列表(lists)，网格(grids)，文本框(text boxes)，按钮(buttons)， 甚至可嵌入的web浏览器；
   2. 内容提供器(Content Providers)使得应用程序可以访问另一个应用程序的数据(如联系人数据库)，或者共享它们自己的数据；
   3. 资源管理器(Resource Manager)提供非代码资源的访问，如本地字符串，图形，和布局文件( layout files )；
   4. 通知管理器 (Notification Manager) 使得应用程序可以在状态栏中显示自定义的提示信息；


- Android Runtime为一个包含了Java语言核心库大多数功能的库，主要承担了动态编译、解释执行dalvik格式的字节码这一jvm角色，每个应用的进程对应了自己的独立的Runtime实例。Dalvik虚拟机执行Dalvik可执行文件(.dex)，该格式文件针对小内存使用做了优化。同时虚拟机是基于寄存器的，所有的类都经由JAVA编译器编译，然后通过SDK中 的 “dx” 工具转化成.dex格式由虚拟机执行。Dalvik虚拟机依赖于linux内核的一些功能，比如线程机制和底层内存管理机制。

- Libraries为一些C/C++开源库，以下是其中一些核心库：
   1. 系统 C 库 (libc)：一个从 BSD 继承来的标准 C 系统函数库( libc )， 它是专门为基于 embedded linux 的设备定制的。
   2. 媒体库 (media framework)：基于 PacketVideo OpenCORE。该库负责支持多种常用的音频、视频格式回放和录制，同时支持静态图像文件。例如MPEG4，H.264，MP3，AAC，AMR，JPG，PNG等格式的文件。
   3. Surface Manager：对显示子系统的管理，并且为多个应用程序提供了2D和3D图层的无缝融合。
   4. LibWebCore：一个最新的web浏览器引擎，用于支持Android浏览器和一个可嵌入的web视图。
   5. web引擎  (webkit)，该函数库负责 android网页浏览器的运行。
   6. SGL/OpenGl ES：底层的2D/3D图形引擎,常用于游戏开发。
   7. FreeType：位图(bitmap)和矢量(vector)字体显示。
   8. SQLite：一个对于所有应用程序可用，功能强劲的轻型关系型数据库引擎。  

- Linux Kernel包含Android的核心系统服务，如安全性，内存管理，进程管理， 网络协议栈和驱动模型。 Linux 内核也同时作为硬件和软件栈之间的抽象层。

#### Framework层分析
&emsp;&emsp;Android FrameWork主要分为以下3个部分内容：服务端、客户端、Linxu驱动。

   1. 服务端包含两个重要的服务类，WindowManagerService（WMS）和ActivityManagerService（AMS）,以及其他的服务管理类。下面是对这些服务类的介绍：
   - WindowManagerService，窗口管理服务，包括动画处理 ，Input分发、处理，Display管理（多屏显示，窗口显示、层序、隐藏）。
   - ActivityManagerService， 负责四大组件的生命周期的调度和管理，同时设计一些些window、电源、权限等内容。
   - PackageManagerService，程序包管理服务
   - PowerManagerService， 电源管理服务
   - BatteryService，电池管理服务
   - NetworkManagerService，网络管理服务
   - BluetoothService，蓝牙管理服务
   - InputMethodManagerService，输入法管理服务
   - LightService，自然光强度感应传感器服务
   - VibratorService，手机震动传感器服务
   - ClipboardService，剪切板服务
   - StatusBarManagerService，状态栏管理服务
   - 还有其他很多服务，不一一概述。
   2. 


#### 多进程及IPC（Inter-Process Communication ）

&emsp;&emsp;对于多进程，一开始我还是感到很陌生，印象仅仅停留在大学时接触到的Socket编程的阶段，对于android的多进程编程也没有太多的关注。通过这几天的学习了解总结一下。  

&emsp;&emsp;首先关于android应用中使用多进程的常见场景，由于android系统对于每个进程分配的资源有限，所以单进程有些应用容易出现OOM（out-of-memory）报错，这时常使用多进程用以分担主进程压力。
	
&emsp;&emsp;在多进程模式中，常常会出现如下问题：  

- 静态成员与单例模式失效

- 线程同步完全失效

- SharedPreferences使用异常

- Application创建多次

&emsp;&emsp;其实这些问题的根本原因是不同的进程运行在不同的虚拟机上，这样每个进程的内存空间也就不同，每个进程中都保留副本（类似多线程），这样静态成员和线程同步也就失效；由于android对于SharedPreferences的读写会保留缓存，这样多进程也就会导致多份缓存发生冲突；而且每个进程启动时，由于分配了独立的虚拟机，所以应用会又启动一次。  

&emsp;&emsp;为了避免这些问题，常常采用多种IPC机制，如AIDL、Messenger、Bundle、Socket等等。这些IPC机制的原理是基于Binder机制实现的,如图为这些IPC机制的特点和应用的场景：  

![各类IPC机制的比较](image/各类IPC机制的比较.PNG)

	

&emsp;&emsp;所谓Binder机制，主要包含Client、Server、ServerManager三个对象，使用到了Proxy代理模式。Binder机制的具体流程如下:  

&emsp;&emsp;首先Client将要发送给Server的请求发送给Proxy代理对象并调用相关功能，这个代理对象需要具备与Server对应的功能接口。然后Proxy将用户请求通过Binder驱动发送到服务器进程。然后服务器处理，再将处理结果通过Binder Driver发送给Proxy，最后Proxy将结果返回给Client。而在实际应用中，Binder就起到了Proxy代理对象的作用，作为数据传输的通道。  

&emsp;&emsp;在android中，Binder类继承IBinder接口，
	
&emsp;&emsp;实际应用中常用的IPC机制有AIDL，Messenger等，下面主要讲一下AIDL机制的使用。

#### AIDL机制的实例

&emsp;&emsp;首先由于进程间通信的数据可能是一个自定义类的对象，这时候就需要将对象序列化后再传输，在AIDL机制中，并不支持自定义类型的数据，但是支持Parcel类型,Parcel类型与Parcelable类型（一种经过）对应。是用于表示一个经过。所以这时一般对自定义对象进行序列化。关于序列化，java中是通过实现Serializable接口来序列化的，而在安卓中，提供了一种更高效，内存开销更少的Parcelabel接口来实现序列化。Parcelable接口需要实现`describeContents()` ，`writeToParcel(Parcel dest, int flags)` 方法，并实例化静态内部接口`Parcelable.Creator` ，Parcelable接口源码（已去掉部分无用注释）如下：  

```java
package android.os;
import android.annotation.IntDef;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
/**
 * <p>A typical implementation of Parcelable is:</p>
 * 
 * <pre>
 * public class MyParcelable implements Parcelable {
 *     private int mData;
 *
 *     public int describeContents() {
 *         return 0;
 *     }
 *
 *     public void writeToParcel(Parcel out, int flags) {
 *         out.writeInt(mData);
 *     }
 *
 *     public static final Parcelable.Creator&lt;MyParcelable&gt; CREATOR
 *             = new Parcelable.Creator&lt;MyParcelable&gt;() {
 *         public MyParcelable createFromParcel(Parcel in) {
 *             return new MyParcelable(in);
 *         }
 *
 *         public MyParcelable[] newArray(int size) {
 *             return new MyParcelable[size];
 *         }
 *     };
 *     
 *     private MyParcelable(Parcel in) {
 *         mData = in.readInt();
 *     }
 * }</pre>
 */
public interface Parcelable {
    /** @hide */
    @IntDef(flag = true, prefix = { "PARCELABLE_" }, value = {
            PARCELABLE_WRITE_RETURN_VALUE,
            PARCELABLE_ELIDE_DUPLICATES,
    })
    @Retention(RetentionPolicy.SOURCE)
    public @interface WriteFlags {}
    /**
     * Flag for use with {@link #writeToParcel}: the object being written
     * is a return value, that is the result of a function such as
     * "<code>Parcelable someFunction()</code>",
     * "<code>void someFunction(out Parcelable)</code>", or
     * "<code>void someFunction(inout Parcelable)</code>".  Some implementations
     * may want to release resources at this point.
     */
    public static final int PARCELABLE_WRITE_RETURN_VALUE = 0x0001;
    /**
     * Flag for use with {@link #writeToParcel}: a parent object will take
     * care of managing duplicate state/data that is nominally replicated
     * across its inner data members.  This flag instructs the inner data
     * types to omit that data during marshaling.  Exact behavior may vary
     * on a case by case basis.
     * @hide
     */
    public static final int PARCELABLE_ELIDE_DUPLICATES = 0x0002;
    /*
     * Bit masks for use with {@link #describeContents}: each bit represents a
     * kind of object considered to have potential special significance when
     * marshalled.
     */
    /** @hide */
    @IntDef(flag = true, prefix = { "CONTENTS_" }, value = {
            CONTENTS_FILE_DESCRIPTOR,
    })
    @Retention(RetentionPolicy.SOURCE)
    public @interface ContentsFlags {}
    /**
     * Descriptor bit used with {@link #describeContents()}: indicates that
     * the Parcelable object's flattened representation includes a file descriptor.
     *
     * @see #describeContents()
     */
    public static final int CONTENTS_FILE_DESCRIPTOR = 0x0001;
    
    /**
     * Describe the kinds of special objects contained in this Parcelable
     * instance's marshaled representation. For example, if the object will
     * include a file descriptor in the output of {@link #writeToParcel(Parcel, int)},
     * the return value of this method must include the
     * {@link #CONTENTS_FILE_DESCRIPTOR} bit.
     *  
     * @return a bitmask indicating the set of special object types marshaled
     * by this Parcelable object instance.
     */
    public @ContentsFlags int describeContents();
    
    /**
     * Flatten this object in to a Parcel.
     * 
     * @param dest The Parcel in which the object should be written.
     * @param flags Additional flags about how the object should be written.
     * May be 0 or {@link #PARCELABLE_WRITE_RETURN_VALUE}.
     */
    public void writeToParcel(Parcel dest, @WriteFlags int flags);
    /**
     * Interface that must be implemented and provided as a public CREATOR
     * field that generates instances of your Parcelable class from a Parcel.
     */
    public interface Creator<T> {
        /**
         * Create a new instance of the Parcelable class, instantiating it
         * from the given Parcel whose data had previously been written by
         * {@link Parcelable#writeToParcel Parcelable.writeToParcel()}.
         * 
         * @param source The Parcel to read the object's data from.
         * @return Returns a new instance of the Parcelable class.
         */
        public T createFromParcel(Parcel source);
        
        /**
         * Create a new array of the Parcelable class.
         * 
         * @param size Size of the array.
         * @return Returns an array of the Parcelable class, with every entry
         * initialized to null.
         */
        public T[] newArray(int size);
    }
    /**
     * Specialization of {@link Creator} that allows you to receive the
     * ClassLoader the object is being created in.
     */
    public interface ClassLoaderCreator<T> extends Creator<T> {
        /**
         * Create a new instance of the Parcelable class, instantiating it
         * from the given Parcel whose data had previously been written by
         * {@link Parcelable#writeToParcel Parcelable.writeToParcel()} and
         * using the given ClassLoader.
         *
         * @param source The Parcel to read the object's data from.
         * @param loader The ClassLoader that this object is being created in.
         * @return Returns a new instance of the Parcelable class.
         */
        public T createFromParcel(Parcel source, ClassLoader loader);
    }
}
```

&emsp;&emsp;其中`describeContent()`方法用于描述特别的序列化对象，`writeToParcel()`方法用于将对象写入Parcel对象中，这里**对成员变量的写入顺序必须与后面的读取顺序相一致**。`Creator<T>`接口内部的抽象函数`createFromParcel()`函数用于从Parcel对象读取数据，`newArray(int size)`用于外部类序列化自身的数组对象。  

&emsp;&emsp;在使用AIDL机制的时候，需要将自定义的数据类型序列化，。  

---

####  Android Activity/Fragment启动生命周期

&emsp;&emsp;activity的生命周期如下图所示，在activity生成时系统会执行activity的`onCreate()`函数，；当activity在屏幕上可见（即便被遮住部分或不能与用户交互）时会调用`onStart()`/`onRestart()`方法；而当activity位于前台，即显示activity的栈的栈顶，则会调用`onResume()`方法（对比`onStart()`）。  

![activity生命周期流程](image/activity生命周期流程.PNG)

&emsp;&emsp;对于`onPause()`（没有位于前台时调用）,`onStop()`（不可见、隐藏于后台时调用）,`onDestroy()`（activity资源释放时调用）方法，分别与`onResume()`,`onStart()`,`onDestroy()`方法对应构成三个周期：  

1. **整个activity的生命周期**，从`onCreate()`到`onDestroy()`,activity从创建到释放的过程。
2. **activity页面的可见周期**，从`onStart()`/`onRestart()`到`onStop()`，activity在屏幕上显示的过程。
3. **activity位于前台的周期**，从`onResume()`到`onPause()`，activity位于最前端能与用户交互的过程。

&emsp;&emsp;上面这些是对activity生命周期的一个基本介绍，具体分析源码，首先是`onCreate()`函数，在这个函数内，activity一般完成布局和变量的初始化,而观察会发先该函数还有一个`Bundle`类型的参数`savedInstanceState`，顾名思义，它是用来保存activity的状态的，在`Activity.onCreate()`执行时会被用来恢复之前activity的状态（如果`savedInstanceState`不为空，则代表有保存之前的状态，判断是否根据改状态恢复）。同时会据此确定 `mAutoFillResetNeeded`这一变量的值，在`Activity.onStart()`函数中根据该变量的值确定自动填充。在`Activity.onResume()`方法中，恢复了试图，所以一般在该方法中实现一些动画效果，或者打开相机或其它独占性的设备。`Activity.onPause()`方法内部没有太多操作，该方法一般用于实现保存一些持久化的对象。`Activity.onStop()`方法根据`mAutoFillResetNeeded`这一变量隐藏页面。`Activity.onDestroy()`执行时，会先根据`isFinishing()`方法来区分是因为调用`finish()`方法还是因为内存不足而被系统销毁，然后对activity做最后的清理。  

#### Activity启动模式

&emsp;&emsp;Activity的启动模式分为4种：Standard,SingleTop,SingleTask,SingleInstance。  

&emsp;&emsp;在Standard模式下，每次创建Activity实例，都会入栈成为栈顶，即便是相同类型的Activity。  

&emsp;&emsp;在SingleTop模式下，与Standard模式稍有不同，若栈顶的Activity类型与即将创建的Activity的类型相同，则直接复用栈顶的Activity，而不会创建新的Activity。若要创建的Activity与栈顶的类型不同，就会新建该Activity并放在栈顶。这种模式下，直接复用不会调用`onCreate()`,`onStart()`方法，但会回调`onNewIntent()`方法。  

&emsp;&emsp;在SingleTask模式下，若栈内有与需要创建的Activity同一类型，则不会创建新的Activity，并将存在栈中的Activity上面的所有其他Activity销毁，使它成为栈顶。   

&emsp;&emsp;在SingleInstance模式下，整个手机系统只能有某类型的Activity的一个实例，并且其他应用打开这类activity时共享同一个该activity。  

&emsp;&emsp;Standard模式用于绝大多数的activity；SingleTop模式一般用于消息页面和浏览器书签页面，不同的消息都展示在同一页面，而不是通过不同的页面来切换，并且能一次性返回到上一页面而不需要连续返回多次；SingleTask模式一般用于app的初始页面，当需要返回到主页面时，直接将主页面之后打开的页面destroy掉；SingleInstance模式一般用于启动其他应用的页面（例如闹钟和闹钟的设置页面以及从某app打开地图）。  





#### View的事件分发流程分析

&emsp;&emsp;对于View的事件分发消费流程，网上有很多介绍，这里就以流程图的形式进行一一阐述,流程图如下：  

![](D:\git_repository\android_wiki\image\view事件分发流程.PNG)

&emsp;&emsp;首先，事件被分发到最外层的Activity以及



#### View的绘制流程分析

&emsp;&emsp;简单的来说，View的绘制流程包括measure（测量）、layout（布局）、draw（绘制）三种阶段。  
	
&emsp;&emsp;首先对于measure阶段，要先介绍MeasureSpec，它是每个布局都具有的**封装了父布局传递给子布局的布局要求**的容器，简单来说，就是每个子View都会根据父View的MeasureSpec和自身的LayoutParams计算出自身的MeasureSpec，然后每个View都会根据自身的MeasureSpec这个测量要求来测量自身。  

&emsp;&emsp;MeasureSpec包含了View的模式和大小信息。View的MeasureSpec一共有3种模式，分别是：  

- UNSPECIFIED:父布局对子布局的大小无限制
- EXACTLY:父容器对子容器的大小设置了尺寸，子容器必须是规定大小的尺寸
- AT_MOST：子容器的大小可以是规定大小以内的任意大小


&emsp;&emsp;然而子View的实际测量结果并不直接根据父View的MeasureSpec确定，还要结合自己的LayoutParams属性。  

  









  ​	

#### 常用布局性能分析
&emsp;&emsp;android中常用的布局有FrameLayout,LinearLayout,RelativeLayout等等，

[参考链接](https://www.jianshu.com/p/b9b3051a4ff6)

---


