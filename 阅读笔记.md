---
阅读笔记   
			--刘鸿志
---
[TOC]
### Java程序运行机制

​	先对Java程序的运行机制做一个概述.Java程序是运行在Java虚拟机(JVM),上而不是直接运行在设备上的.JVM大致的模型如下:

​	首先程序编译生成的.class文件经过Class Loader加载（负责对数据进行校验和初始化），然后再在Runtime Data Area开辟程序运行时所需要的内存区域（包括堆栈内存、函数区内存、常量区、程序固定内存等等，部分为线程共享），对数据管理。分配完内存后就是通过java虚拟机进行解释执行，并通过native library与其他编程语言交互。



---



### 程序的并发机制

​	所谓并发，一般都是与并行相对来讲的，通俗来说。并发是指多任务以时间片轮转的形式有序执行等，从而导致宏观上像是多任务同时进行（并行）。并发机制一般表现为**多线程**或**多进程**的形式。而对于这种多任务并发的形式，首先要分析多任务之间如何交流。

#### 多线程及其之间通信

​	对于多进程而言,得提到上面讲过的JVM中的内存区的管理，Java虚拟机内存模型（JMM）如下图：

​	其中主存区中的堆内存和函数区的内存都是线程共享的，而每个线程也单独拥有自己的堆栈内存。

​	所谓线程共享，即每个线程都会在自身的堆栈内存中为共享区域的内存保留一份copy，然后单独操作自己的copy。若要实现对共享内存区的共同维护，则需要通过Synchronized同步锁或者Lock锁对象**(安全)**或者对共享变量添加volatile关键字**（不安全）**的方式实现。

​	举个例子，代码如下，当线程A执行`Market m = new Market();	m.buy();`后，线程B读取goods值为4，原因是二者维护的是同一块内存区域（位于主存的变量goods）。如果按注释那样去掉volatile关键字，A线程再进行同样的操作，B线程获取到的goods值却为5，原因正是AB两个线程这个时候维护的是各自对主存这块区域的copy，所以互不影响。

```java
public class Market{
    // public int goods = 5;
    public volatile int goods = 5;
    public void buy(){
        this.goods--;
    }
}
```

​	但是这里常常有一个误区，那就是关于volatile关键字与Synchronized同步锁机制的区别。volatile修饰的变量是**不具有原子性**的，只能保证对内存区域的修改对于其他线程可见。也就是当多个线程同时对volatile进行修改操作后，所得的值会与预计中的有差异。但Synchronized同步锁会使多线程对同一内存区域的读取具有同步性，从而实现原子性的操作。就好比很多人都有钥匙，但只能一个一个地开锁进去。

​	关于线程间具体的通信，还需要用到`wait()`跟`notify()`配合的线程等待和唤醒机制，但这种方式下notify不能唤醒指定的线程，所以一般都使用Lock绑定多个condition监视，然后通过condition对象来使指定的线程等待或唤醒。

​	Lock锁的使用实例如下，

#### 线程池的原理和搭建

​	所谓线程池，通俗来说就是容放多个线程的空间，线程池内的线程并发执行多个任务。当有任务需要执行时，线程池会派出一个线程去执行。当线程执行完任务后就会回到线程池等待分配新的任务而不是立刻销毁。直到线程池所有线程都被使用，多余的任务就会进入等待队列等待，直到线程池出现新的闲置的线程。

##### 源码分析

​	有关线程池的类与接口的关系可参考下图：

​	//executor\executorservice等等关系图

​	Java中通过`Executors`提供4种线程池的创建，分别如下：

- `Executors.newCachedThreadPool()`提供一个线程数量不固定的线程池（最多2147483647个线程，Integer的最大值,可视为无限数量），线程池内的线程回收后的60s内可执行其它任务，若闲置时间超过60s就会自动销毁。返回类型为`ExecutorService`（实际为`ThreadPoolExecutor`对象的向上转型）。
- `Executors.newFixedThreadPool()` 提供一个线程数量固定的线程池，执行完任务的线程不会销毁，在线程池中等待。线程数量通过参数指定，返回对象类型为`ExecutorService`（也为`ThreadPoolExecutor`对象的向上转型）。

- `Executors.newScheduledThreadPool()`提供一个线程数量固定的线程池，与上一个类型的线程池相比，//介绍				返回对象类型为`ScheduledExecutorService`（实际为`ScheduledThreadPoolExecutor`）。 
- `Executors.newSingleThreadExecutor()`提供一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行 。返回对象类型为`ExecutorService`（ 实际为`ThreadPoolExecutor`）。


Java中线程池的搭建离不开`ThreadPoolExecutor`类，`ThreadPoolExecutor`类是继承自`AbstractExecutorService`抽象类,该类实现了`Executor`、`ExecutorService`接口,`Executor`接口内只有`void execute(Runnable command)`接口函数，抽象了具体的任务执行过程。



​	、`ExcutorService()`内部接口函数比较多，挑几个主要的讲。`submit()`接口抽象了任务的执行提交过程，与`execute()`方法不同的是，该方法返回了一个`Future`对象来表示任务执行的结果，Future
	
​	//线程池的搭建



#### 多进程及IPC（Inter-Process Communication ）

​	对于多进程，一开始我还是感到很陌生，印象仅仅停留在大学时学到的Socket编程的阶段，对于android的多进程编程也没有太多的接触。通过这几天的学习了解总结一下。

​	首先关于android应用中使用多进程的常见场景，由于android系统对于每个进程分配的资源有限，所以单进程有些应用容易出现OOM（out-of-memory）报错，这时常使用多进程用以分担主进程压力。

​	在多进程模式中，常常会出现如下问题：

- 静态成员与单例模式失效

- 线程同步完全失效

- SharedPreferences使用异常

- Application创建多次

其实这些问题的根本原因是不同的进程运行在不同的虚拟机上，这样每个进程的内存空间也就不同，每个进程中都保留副本（类似多线程），这样静态成员和线程同步也就失效；由于android对于SharedPreferences的读写会保留缓存，这样多进程也就会导致多份缓存发生冲突；而且每个进程启动时，由于分配了独立的虚拟机，所以应用会又启动一次。

​	为了避免这些问题，常常采用多种IPC机制，如AIDL、Messenger、Bundle、Socket等等。这些IPC机制的原理是基于Binder机制实现的。

​	Binder机制，主要包含Client、Server、ServerManager三个对象，使用到了Proxy代理模式。Binder机制的具体流程如下

​	首先Client将要发送给Server的请求发送给Proxy代理对象并调用相关功能，这个代理对象需要具备与Server对应的功能接口。然后Proxy将用户请求通过Binder驱动发送到服务器进程。然后服务器处理，再将处理结果通过Binder Driver发送给Proxy，最后Proxy将结果返回给Client。

​	

[参考链接][https://www.jianshu.com/p/b9b3051a4ff6]

---






