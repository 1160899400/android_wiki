---
阅读笔记   
			--刘鸿志
---
[TOC]
### Java程序运行机制

​	先对Java程序的运行机制做一个概述.Java程序是运行在Java虚拟机(JVM),上而不是直接运行在设备上的.JVM大致的模型如下:

​	首先程序编译生成的.class文件经过Class Loader加载（负责对数据进行校验和初始化），然后再在Runtime Data Area开辟程序运行时所需要的内存区域（包括堆栈内存、函数区内存、常量区、程序固定内存等等，部分为线程共享），对数据管理。分配完内存后就是通过java虚拟机进行解释执行，并通过native library与其他编程语言交互。



---



### 程序的并发机制

​	所谓并发，一般都是与并行相对来讲的，通俗来说。并发是指多任务以时间片轮转的形式有序执行等，从而导致宏观上像是多任务同时进行（并行）。并发机制一般表现为**多线程**或**多进程**的形式。而对于这种多任务并发的形式，首先要分析多任务之间如何交流。

#### 多线程及其之间通信

​	对于多进程而言,得提到上面讲过的JVM中的内存区的管理，Java虚拟机内存模型（JMM）如下图：

​	其中主存区中的堆内存和函数区的内存都是线程共享的，而每个线程也单独拥有自己的堆栈内存。

​	所谓线程共享，即每个线程都会在自身的堆栈内存中为共享区域的内存保留一份copy，然后单独操作自己的copy。若要实现对共享内存区的共同维护，则需要通过Synchronized同步锁**(安全)**或者对共享变量添加volatile关键字**（不安全）**的方式实现。

​	举个例子，代码如下，当线程A执行`Market m = new Market();	m.buy();`后，线程B读取goods值为4，原因是二者维护的是同一块内存区域（位于主存的变量goods）。如果按注释那样去掉volatile关键字，A线程再进行同样的操作，B线程获取到的goods值却为5，原因正是AB两个线程这个时候维护的是各自对主存这块区域的copy，所以互不影响。

​	但是这里常常有一个误区，那就是关于volatile关键字与Synchronized同步锁机制的区别。volatile修饰的变量是**不具有原子性**的，只能保证对内存区域的修改对于其他线程可见。也就是当多个线程同时对volatile进行修改操作后，所得的值会与预计中的有差异。但Synchronized同步锁会使多线程对同一内存区域的读取具有同步性，从而实现原子性的操作。就好比很多人都有钥匙，但只能一个一个地开锁进去。

​	关于线程间具体的通信，还需要用到`wait()`跟`notify()`配合的线程等待和唤醒机制。

​	//同步锁的wait和notify等待回去查阅

```java
public class Market{
    // public int goods = 5;
    public volatile int goods = 5;
    public void buy(){
        this.goods--;
    }
}
```

#### 线程池的原理和搭建

​	线程池的

​	//线程池的搭建


#### 多进程及IPC（Inter-Process Communication ）

​	对于多进程，一开始我还是感到很陌生，印象仅仅停留在大学时学到的Socket编程的阶段，对于android的多进程编程也没有太多的接触。通过这几天的学习了解总结一下。

​	首先关于android应用中使用多进程的常见场景，由于android系统对于每个进程分配的资源有限，所以单进程有些应用容易出现OOM（out-of-memory）报错，这时常使用多进程用以分担主进程压力。

​	在多进程模式中，常常会出现如下问题：

- 静态成员与单例模式失效

- 线程同步完全失效

- SharedPreferences使用异常

- Application创建多次

其实这些问题的根本原因是不同的进程运行在不同的虚拟机上，这样每个进程的内存空间也就不同，每个进程中都保留副本（类似多线程），这样静态成员和线程同步也就失效；由于android对于SharedPreferences的读写会保留缓存，这样多进程也就会导致多份缓存发生冲突；而且每个进程启动时，由于分配了独立的虚拟机，所以应用会又启动一次。

​	为了避免这些问题，常常采用多种IPC机制，如AIDL、Messenger、Bundle、Socket等等。这些IPC机制的原理是基于Binder机制实现的。

​	Binder机制，主要包含Client、Server、ServerManager三个对象，使用到了Proxy代理模式。Binder机制的具体流程如下

​	首先Client将要发送给Server的请求发送给Proxy代理对象，这个代理对象需要具备与Server对应的功能接口。然后Proxy将用户请求通过Binder驱动发送到服务器进程。然后服务器处理，再将处理结果通过Binder Driver发送给Proxy。

[参考链接][https://www.jianshu.com/p/b9b3051a4ff6]

---






